import React, { useState, useRef, useEffect, KeyboardEvent } from 'react';
import { Helmet } from 'react-helmet-async';
import {
  Box, Button, Card, CardHeader, CardContent, Collapse, Divider,
  IconButton, Paper, TextareaAutosize, TextField, CircularProgress, Grid, MenuItem
} from '@mui/material';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import SendIcon       from '@mui/icons-material/Send';
import MicIcon        from '@mui/icons-material/Mic';
import MicOffIcon     from '@mui/icons-material/MicOff';
import SpeechRecognition, { useSpeechRecognition } from 'react-speech-recognition';
import { useTheme, useMediaQuery } from '@mui/material';
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
interface Message { role: 'user' | 'assistant'; content: string }
type Conn = 'idle' | 'connecting' | 'connected' | 'error';

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
export default function Talker() {
  /* state */
  const params   = new URLSearchParams(location.search);
  const paramMobile = params.get('mobile') === 'true';
  const theme    = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md')) || paramMobile; 
  
  // const API_URL = 'https://e359-163-180-179-152.ngrok-free.app'
  const API_URL = "https://52li03441j52k0-8010.proxy.runpod.net"
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput]       = useState('');
  const [sessionId, setSid]     = useState<number | null>(null);
  const [status, setStatus]     = useState<Conn>('idle');
  const [openCard, setOpenCard] = useState(false);
  const [micOn,   setMicOn]     = useState(false);      // NEW â€“ tracks userâ€™s toggle
  const [modelId, setModelId]   = useState(''); 
  const [temperature, setTemperature] = useState(0.3);
  const [language, setLanguage] = useState('en-US');

  const clampTemp = (v: number) => Math.min(1, Math.max(0.1, Number(v.toFixed(2))));

  /* refs */
  const pcRef        = useRef<RTCPeerConnection | null>(null);
  const videoRef     = useRef<HTMLVideoElement | null>(null);
  const listRef      = useRef<HTMLDivElement | null>(null);
  const silenceTimer = useRef<NodeJS.Timeout | null>(null);

  /* speech */
  const { transcript, listening, resetTranscript,
          browserSupportsSpeechRecognition } = useSpeechRecognition();

  /* ========== helpers ========== */
  const cleanUpPc = () => {
    const pc = pcRef.current;
    if (pc) {
      pc.getReceivers().forEach(r => r.track?.stop());
      pc.getSenders().forEach(s => s.track?.stop());
      pc.close();
      pcRef.current = null;
    }
    if (videoRef.current) videoRef.current.srcObject = null;
  };
  const connect = async () => {
    cleanUpPc();
    setStatus('connecting');
    try {
      const pc = new RTCPeerConnection({
        iceServers: [
          {
            urls: 'stun:stun.l.google.com:19302'
          },
          {
            urls: 'turn:relay1.expressturn.com:3478',
            username: 'efTYZ01RL1QUJ5CFUX',
            credential: 'AOZVt0YaAPWCJPbQ'
          }
        ],
        iceTransportPolicy: 'all',
        bundlePolicy: 'balanced',
        rtcpMuxPolicy: 'require'
      });
  
      pcRef.current = pc;
  
      pc.addTransceiver('video', { direction: 'recvonly' });
      pc.addTransceiver('audio', { direction: 'recvonly' });
  
      pc.onconnectionstatechange = () => {
        if (pc.connectionState === 'connected') setStatus('connected');
        if (pc.connectionState === 'failed') setStatus('error');
      };
  
      pc.ontrack = (e) => {
        if (videoRef.current && e.streams[0]) {
          videoRef.current.srcObject = e.streams[0];
          videoRef.current.play().catch(() => {});
        }
      };
  
      await pc.setLocalDescription(await pc.createOffer());
  
      /* cap ICE gather to 5s */
      await new Promise<void>((res) => {
        const t = setTimeout(res, 8000);
        pc.onicecandidate = (ev) => {
          if (!ev.candidate) { clearTimeout(t); res(); }
        };
      });
  
      const reply = await fetch(`${API_URL}/offer`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sdp: pc.localDescription!.sdp,
          type: pc.localDescription!.type
        })
      });
  
      const ans = await reply.json();   // { sdp, type, sessionid }
      setSid(ans.sessionid);
      await pc.setRemoteDescription(new RTCSessionDescription(ans));
    } catch (err) {
      console.error('Connection error:', err);
      setStatus('error');
    }
  };
  
  const disconnect = () => {
    cleanUpPc();
    setStatus('idle');
    setSid(null);
  };
  
  const OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY;
  const systemPrompt = `
  You are a digital human speaking language based on prompt.
  When generating output:
  
  - Reply no more than 400 tokens, answer concisely and short.
  - Do NOT use asterisks (*), exclamation marks (!), at symbols (@), hashtags (#), dollar signs ($), or other special symbols. (If % use text 'percent')
  - Do NOT output markdown formatting (no bold, italics, headers, etc.)
  `.trim();
  
  const callGPT = async (userText: string): Promise<string> => {
    if (modelId.trim()) {
      try {
        const endpoint = `https://console.vais.app/api/inference-llm/${modelId.trim()}`;
        const resp = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            input       : userText,
            temperature : temperature,
            max_tokens  : 512
          })
        });
  
        if (!resp.ok) {
          console.error('Custom model error', await resp.text());
          return '(custom model error)';
        }
  
        const data = await resp.json();
        // server usually returns { answer: "..."}  â€“ adjust if your field differs
        return data.answer ?? data.result ?? JSON.stringify(data);
      } catch (err) {
        console.error(err);
        return '(custom model call failed)';
      }
    }
  
    // â”€â”€ B) otherwise fall back to OpenAI GPT-4o  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (!OPENAI_API_KEY) { console.error('âš ï¸  OPENAI API key missing'); return '(no API key)'; }
  
    const chatPayload = [
      { role: 'system', content: systemPrompt },
      ...messages.map(m => ({ role: m.role, content: m.content })),
      { role: 'user', content: userText }
    ];
  
    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method : 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${OPENAI_API_KEY}` },
      body   : JSON.stringify({ model: 'gpt-4o-mini', messages: chatPayload,
                                temperature: 0.7, max_tokens: 512 })
    });
  
    if (!resp.ok) { console.error('OpenAI error', await resp.text()); return '(error getting answer)'; }
  
    let output = (await resp.json()).choices?.[0]?.message?.content ?? '(no answer)';
  
    output = output
      .replace(/[\u4e00-\u9fff]/g, '')
      .replace(/[^\x00-\x7F]+/g, '')
      .replace(/[*@#\$%\^&\(\)_\+=!~`<>{}\[\]\|\\\/]/g, '')
      .replace(/\s{2,}/g, ' ')
      .trim();
  
    return output;
  };

  /* push assistant text to backend */
  const pushToAvatar = async (txt: string) => {
    if (sessionId == null) return;
    await fetch(`${API_URL}/human`, {
      method : 'POST',
      headers: { 'Content-Type': 'application/json' },
      body   : JSON.stringify({ type: 'echo', text: txt, interrupt: true, sessionid: sessionId })
    });
  };

  /* ------------ unified handler ------------ */
  const processUserText = async (userText: string) => {
    const t = userText.trim(); if (!t) return;
    setMessages(p => [...p, { role: 'user', content: t }]);
    const assistantText = await callGPT(t);
    setMessages(p => [...p, { role: 'assistant', content: assistantText }]);
    pushToAvatar(assistantText);
  };

  /* manual send */
  const submit = () => { const t = input.trim(); if (!t) return;
                         setInput(''); processUserText(t); };
  const onKey = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); submit(); }
  };

  useEffect(() => {
    if (status === 'connected' && !micOn) {
      if (!browserSupportsSpeechRecognition) return;
      setMicOn(true);
      resetTranscript();
      SpeechRecognition.startListening({ continuous: true, language: language });
    }
  }, [status]);

  /* list autoscroll */
  useEffect(() => { listRef.current?.scrollTo({ top: listRef.current.scrollHeight }); }, [messages]);
  useEffect(() => {
    const el = listRef.current; if (!el) return;
    requestAnimationFrame(() => { el.scrollTop = el.scrollHeight; });
  }, [messages, openCard]);

  useEffect(() => {
    if (!listening) { if (silenceTimer.current) clearTimeout(silenceTimer.current); return; }
    if (silenceTimer.current) clearTimeout(silenceTimer.current);
    silenceTimer.current = setTimeout(() => {
      const t = transcript.trim();
      if (t) {
        SpeechRecognition.stopListening();
        resetTranscript();
        processUserText(t);
      }
    }, 1200);
  }, [transcript, listening]);

  useEffect(() => {
    if (!micOn) {                               // user turned mic off
      if (silenceTimer.current) clearTimeout(silenceTimer.current);
      return;
    }

    // restart timer every time transcript changes
    if (silenceTimer.current) clearTimeout(silenceTimer.current);
    silenceTimer.current = setTimeout(async () => {
      const spoken = transcript.trim();
      if (!spoken) return;                      // no text captured

      SpeechRecognition.stopListening();        // stop to freeze final text
      resetTranscript();
      await processUserText(spoken);            // <-- your existing handler

      // immediately resume hands-free listening
      if (micOn) {
        resetTranscript();
        SpeechRecognition.startListening({ continuous: true, language: 'en-US' });
      }
    }, 1500);                                   // 4-second gap
  }, [transcript, micOn]);                      // run on every change

  /* ---------- mic button ---------- */
  const toggleMic = async () => {
    if (!browserSupportsSpeechRecognition) {
      alert("Speech Recognition is not supported. Please update or use Chrome/Edge browser.");
      return;
    }
    if (micOn) { 
      setMicOn(false);
      SpeechRecognition.stopListening();
      const spoken = transcript.trim();
      resetTranscript();
      if (spoken) await processUserText(spoken);
    } else { // turn ON
      setMicOn(true);
      resetTranscript();
      SpeechRecognition.startListening({ continuous: true, language: language });
    }
  };

  const LANGUAGES = [
    { code: 'en-US', label: 'English (US)', flag: 'ðŸ‡ºðŸ‡¸' },
    { code: 'en-GB', label: 'English (UK)', flag: 'ðŸ‡¬ðŸ‡§' },
    { code: 'fr-FR', label: 'French',      flag: 'ðŸ‡«ðŸ‡·' },
    { code: 'de-DE', label: 'German',      flag: 'ðŸ‡©ðŸ‡ª' },
    { code: 'ko', label: 'Korean',      flag: 'ðŸ‡°ðŸ‡·' },
    { code: 'ja', label: 'Japanese',    flag: 'ðŸ‡¯ðŸ‡µ' },
    { code: 'zh-CN', label: 'Chinese',     flag: 'ðŸ‡¨ðŸ‡³' },
    { code: 'ms-MY', label: 'Malay',       flag: 'ðŸ‡²ðŸ‡¾' },
    { code: 'id', label: 'Indonesian',  flag: 'ðŸ‡®ðŸ‡©' }
  ];
  

  // useEffect(() => {
  //   const t = setTimeout(() => {
  //     if (status === 'idle') connect();
  //   }, 4000);
  //   return () => clearTimeout(t);
  // }, []);
  
  return (
    <>
      <Helmet><title>Live VAIS</title></Helmet>
  
      <Grid container 
        spacing={{ xs: 0, md: 3 }}
          sx={{
            height: '100%',
            color: '#E3E3E3',
            px: { xs: 0, md: 3 },                // no horizontal padding on mobile
            py: 3 
          }}
        >
        {/* LEFT COLUMN */}
        <Grid
          item
          xs={12}
          md={2}
          sx={{
            // force-hide on mobile/tablet, show on md+ (desktop)
            display: isMobile
              ? 'none'
              : { xs: 'none', md: 'flex' },
            flexDirection: 'column',
            gap: 2
          }}
        >
          <Grid container>
            <Grid item xs={11} md={11} sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
            {!isMobile && (
              <>
                <TextField
                  label="Trained Model ID"
                  placeholder="abcdeâ€¦-5000"
                  size="small"
                  value={modelId}
                  onChange={e => setModelId(e.target.value)}
                  InputLabelProps={{ sx: { color: '#9fa1a7' } }}
                  fullWidth
                />

                <TextField
                  label="Temperature"
                  type="number"
                  size="small"
                  inputProps={{ step: .1, min: .1, max: 1 }}
                  value={temperature}
                  onChange={e => {
                    const v = parseFloat(e.target.value);
                    setTemperature(clampTemp(isNaN(v) ? 0.3 : v));
                  }}
                  InputLabelProps={{ sx: { color: '#9fa1a7' } }}
                  fullWidth
                />

                <TextField
                  label="Language"
                  select
                  size="small"
                  value={language}
                  onChange={e => setLanguage(e.target.value)}
                  fullWidth
                >
                  {LANGUAGES.map(lang => (
                    <MenuItem key={lang.code} value={lang.code}>
                      <span style={{ marginRight: 8 }}>{lang.flag}</span> {lang.label}
                    </MenuItem>
                  ))}
                </TextField>
              </>
            )}
            </Grid>
          </Grid>
        </Grid>
  
        {/* RIGHT COLUMN */}
        <Grid item xs={12} lg={9} md={12} sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
          <Box
              sx={{
                position:   'relative',
                flexGrow:   1,
                display:    'flex',
                justifyContent: isMobile ? 'center'     : 'flex-start',
                alignItems:     isMobile ? 'center'     : 'flex-start',
                width:           '100%',
                height:          isMobile ? '100vh'     : 'auto'
              }}
            >
              <video
                ref={videoRef}
                autoPlay
                playsInline
                style={{
                  width:      '100%',                        // full width
                  height:     isMobile
                              ? '100%'                     // fills the wrapper's 100vh
                              : (openCard ? '60vh' : '72vh'),
                  objectFit:  isMobile ? 'cover' : 'contain',
                  background: '#000',
                  borderRadius: isMobile ? 0 : 12           // zero radius on mobile
                }}
              />
              {status === 'connecting' && (
                <Box
                  sx={{
                    position: 'absolute',
                    top: 0, left: 0, right: 0, bottom: 0,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    backgroundColor: 'rgba(0, 0, 0, 0.4)',
                    borderRadius: 12,
                    zIndex: 1
                  }}
                >
                  <CircularProgress color="inherit" />
                </Box>
              )}
          </Box>
          <Card sx={{
            mt: 2,
            bgcolor: '#202123',
            color: '#E3E3E3',
            width: { xs: '100%', md: '80%' },
            mx: 'auto'
          }}>
            <CardHeader
              title="Show Conversation"
              sx={{ '.MuiCardHeader-title': { fontSize: 16 }, py: 0.85 }}
              action={
                <IconButton sx={{ color: '#fff' }} onClick={() => setOpenCard(o => !o)}>
                  {openCard ? <ExpandLessIcon /> : <ExpandMoreIcon />}
                </IconButton>
              }
            />
            <Collapse in={openCard} unmountOnExit>
              <Divider />
              <CardContent sx={{ p: 0 }}>
                <Box
                  ref={listRef}
                  sx={{ height: 160, overflowY: 'auto', px: 3, pt: 2, pb: 1 }}
                >
                  {messages.map((m, i) => (
                    <Box
                      key={i}
                      sx={{
                        display: 'flex',
                        justifyContent: m.role === 'user' ? 'flex-end' : 'flex-start',
                        mb: 1.5
                      }}
                    >
                      <Paper elevation={3}
                        sx={{
                          px: 2,
                          py: 1,
                          maxWidth: '75%',
                          bgcolor: m.role === 'user' ? '#3E3F4B' : '#202123',
                          color: '#E3E3E3',
                          fontSize: 14,
                          whiteSpace: 'pre-wrap',
                          borderTopRightRadius: m.role === 'user' ? 0 : 2,
                          borderTopLeftRadius:  m.role === 'assistant' ? 0 : 2,
                          borderBottomRightRadius: 2,
                          borderBottomLeftRadius:  2
                        }}
                      >
                        {m.content}
                      </Paper>
                    </Box>
                  ))}
                </Box>
              </CardContent>
            </Collapse>
  
            <Divider />
            <Box sx={{
              position: 'sticky',
              bottom: 0,
              left: 0,
              right: 0,
              bgcolor: '#202123',
              px: 2,
              py: 1.2,
              display: 'flex',
              alignItems: 'flex-end',
              gap: 1.5
            }}>
              <TextareaAutosize
                value={input}
                onChange={e => setInput(e.target.value)}
                onKeyDown={onKey}
                minRows={1}
                placeholder="Send a messageâ€¦"
                style={{
                  flexGrow: 1,
                  resize: 'none',
                  background: 'transparent',
                  border: 0,
                  outline: 'none',
                  color: '#fff',
                  fontSize: 14
                }}
              />
  
              <IconButton
                onClick={toggleMic}
                sx={{ bgcolor: micOn ? '#ff1744' : '#343541', width: 28, height: 28 }}
              >
                {micOn ? <MicIcon sx={{ color: '#fff' }} /> : <MicOffIcon sx={{ color: '#fff' }} />}
              </IconButton>
  
              {status === 'idle' || status === 'error' ? (
                <Button size="small" variant="contained" onClick={connect}>Start</Button>
              ) : status === 'connecting' ? (
                <Button size="small" disabled>Connectingâ€¦</Button>
              ) : (
                <Button size="small" color="error" onClick={disconnect}>Stop</Button>
              )}
            </Box>
          </Card>

        </Grid>
  

      </Grid>
    </>
  );
}  